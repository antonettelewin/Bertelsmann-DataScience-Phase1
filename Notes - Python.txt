Lesson 24
Arithmetic Operations
  +   addition
  -   subtraction
  *   multiplcation
  /   division
  **  exponential
  %   modulo (returns remainer)
  //  interger diviaon (sums down answer to whole number 3.5=3)
  
There are two Python data types that could be used for numeric values:
  int - for integer values
  float - for decimal or floating point values
  x = int(4.7)   # x is now an integer 4
  y = float(4)   # y is now a float of 4.0

Type And Type Conversion
  You have seen four data types so far:
    int
    float
    bool
    string
    
String Methods
  Methods are like some of the functions you have already seen:
    len("this")
    type(12)
    print("Hello world")
  These three above are functions - notice they use parentheses, and accept one or more arguments. 

  A method in Python behaves similarly to a function. Methods actually are functions that are called using dot notation. For example, lower() is a string method that can be used like this, on a string called "sample string": sample_string.lower().

  Methods are specific to the data type for a particular variable. 
    
Lists!
  You saw here that you can create a list with square brackets. Lists can contain any mix and match of the data types you have seen so far.
Useful Functions for Lists I
  len() returns how many elements are in a list.
  max() returns the greatest element of the list. 
  min() returns the smallest element in a list. 
  sorted() returns a copy of a list in order from smallest to largest, leaving the list unchanged.
  join()  takes a list of strings as an argument, and returns a string consisting of the list elements joined by a separator string.
  append() adds an element to the end of a list
  
Tuples
  A tuple is another useful container. It's a data type for immutable ordered sequences of elements. They are often used to store related pieces of information. 
  Tuples are similar to lists in that they store an ordered collection of objects which can be accessed by their indices. Unlike lists, however, tuples are immutable - you can't add and remove items from tuples, or sort them in place.
  
Sets
  A set is a data type for mutable unordered collections of unique elements. One application of a set is to quickly remove duplicates from a list.

  numbers = [1, 2, 6, 3, 1, 1, 6]
  unique_nums = set(numbers)
  print(unique_nums)
  This would output:
  {1, 2, 3, 6}

  Sets support the in operator the same as lists do. You can add elements to sets using the add method, and remove elements using the pop method, similar to lists. Although, when you pop an element from a set, a random element is removed. Remember that sets, unlike lists, are unordered so there is no "last element".
  
Dictionaries
  A dictionary is a mutable data type that stores mappings of unique keys to values. Here's a dictionary that stores elements and their atomic numbers.
    elements = {"hydrogen": 1, "helium": 2, "carbon": 6}
  We can check whether a value is in a dictionary the same way we check whether a value is in a list or set with the in keyword. Dicts have a related method that's also useful, get. get looks up values in a dictionary, but unlike square brackets, get returns None (or a default value of your choice) if the key isn't found.
 
Identity Operators 
  You can check if a key returned None with the is operator. You can check for the opposite using is not.
    n = elements.get("dilithium")
    print(n is None)
    print(n is not None)
  
Compound Data Structures
  We can include containers in other containers to create compound data structures.
    elements = {"hydrogen": {"number": 1,
                             "weight": 1.00794,
                             "symbol": "H"},
                  "helium": {"number": 2,
                             "weight": 4.002602,
                             "symbol": "He"}}
  We can access elements in this nested dictionary like this.
    helium = elements["helium"]  # get the helium dictionary
    hydrogen_weight = elements["hydrogen"]["weight"]  # get hydrogen's weight
  You can also add a new key to the element dictionary.
    oxygen = {"number":8,"weight":15.999,"symbol":"O"}  # create a new oxygen dictionary 
    elements["oxygen"] = oxygen  # assign 'oxygen' as a key to the elements dictionary
    print('elements = ', elements)
    
List are sortable, you can add an item to a list with .append and list items are always indexed with numbers starting at 0.
Sets are not ordered, so the order in which items appear can be inconsistent and you add items to sets with .add. Like dictionaries and lists, sets are mutable.You cannot have the same item twice and you cannot sort sets. For these two properties a list would be more appropriate.
Each item in a dictionary contains two parts (a key and a value), the items in a dictionary are not ordered, and we have seen in this lesson examples of nested dictionaries. Because dictionaries are not ordered, they are not sortable. And you do not add items to a dictionary with .append.


LESSON 25
If Statement
  An if statement is a conditional statement that runs or skips code based on whether a condition is true or false.
    if phone_balance < 5:
    phone_balance += 10
    bank_balance -= 10
    
If, Elif, Else
    if season == 'spring':
        print('plant the garden!')
    elif season == 'summer':
        print('water the garden!')
    elif season == 'fall':
        print('harvest the garden!')
    elif season == 'winter':
        print('stay indoors!')
    else:
        print('unrecognized season')
  if: An if statement must always start with an if clause, which contains the first condition that is checked. 
  elif: elif is short for "else if." An elif clause is used to check for an additional condition if the conditions in the previous clauses in the if statement evaluate to False. 
  else: Last is the else clause, which must come at the end of an if statement if used. This clause doesn't require a condition.

  
Complex Boolean Expressions
	If statements sometimes use more complicated boolean expressions for their conditions. They may contain multiple comparisons operators, logical operators, and even calculations. Examples:

	if 18.5 <= weight / height**2 < 25:
		print("BMI is considered 'normal'")

	if is_raining and is_sunny:
		print("Is there a rainbow?")

	if (not unsubscribed) and (location == "USA" or location == "CAN"):
		print("send email")
		
For Loops
	Python has two kinds of loops - for loops and while loops. A for loop is used to "iterate", or do something repeatedly, over an iterable.

	An iterable is an object that can return one of its elements at a time. This can include sequence types, such as strings, lists, and tuples, as well as non-sequence types, such as dictionaries and files.

Using the Range() Function with For Loops
	range() is a built-in function used to create an iterable sequence of numbers. 
	The range() function takes three integer arguments, the first and third of which are optional:
		The 'start' argument is the first number of the sequence. If unspecified, 'start' defaults to 0.
		The 'stop' argument is 1 more than the last number of the sequence. This argument must be specified.
		The 'step' argument is the difference between each number in the sequence. If unspecified, 'step' defaults to 1.
		
Creating and Modifying Lists
	In addition to extracting information from lists, as we did in the first example above, you can also create and modify lists with for loops. You can create a list by appending to a new list at each iteration of the for loop like this:
		# Creating a new list
		cities = ['new york city', 'mountain view', 'chicago', 'los angeles']
		capitalized_cities = []

		for city in cities:
			capitalized_cities.append(city.title())
	Modifying a list is a bit more involved, and requires the use of the range() function.

	We can use the range() function to generate the indices for each value in the cities list. This lets us access the elements of the list with cities[index] so that we can modify the values in the cities list in place.
		cities = ['new york city', 'mountain view', 'chicago', 'los angeles']

		for index in range(len(cities)):
			cities[index] = cities[index].title()clauses in the if statement evaluate to False. 
  else: Last is the else clause, which must come at the end of an if statement if used. This clause doesn't require a condition.

Complex Boolean Expressions
	If statements sometimes use more complicated boolean expressions for their conditions. They may contain multiple comparisons operators, logical operators, and even calculations. Examples:

	if 18.5 <= weight / height**2 < 25:
		print("BMI is considered 'normal'")

	if is_raining and is_sunny:
		print("Is there a rainbow?")

	if (not unsubscribed) and (location == "USA" or location == "CAN"):
		print("send email"FOR NAME
		
For Loops
	Python has two kinds of loops - for loops and while loops. A for loop is used to "iterate", or do something repeatedly, over an iterable.

	An iterable is an object that can return one of its elements at a time. This can include sequence types, such as strings, lists, and tuples, as well as non-sequence types, such as dictionaries and files.

Using the Range() Function with For Loops
	range() is a built-in function used to create an iterable sequence of numbers. 
	The range() function takes three integer arguments, the first and third of which are optional:
		The 'start' argument is the first number of the sequence. If unspecified, 'start' defaults to 0.
		The 'stop' argument is 1 more than the last number of the sequence. This argument must be specified.
		The 'step' argument is the difference between each number in the sequence. If unspecified, 'step' defaults to 1.
		
Creating and Modifying Lists
	In addition to extracting information from lists, as we did in the first example above, you can also create and modify lists with for loops. You can create a list by appending to a new list at each iteration of the for loop like this:
		# Creating a new list
		cities = ['new york city', 'mountain view', 'chicago', 'los angeles']
		capitalized_cities = []

		for city in cities:
			capitalized_cities.append(city.title())
	
	Modifying a list is a bit more involved, and requires the use of the range() function.
	We can use the range() function to generate the indices for each value in the cities list. This lets us access the elements of the list with cities[index] so that we can modify the values in the cities list in place.
		cities = ['new york city', 'mountain view', 'chicago', 'los angeles']

		for index in range(len(cities)):
			cities[index] = cities[index].title()


Iterating Through Dictionaries with For Loops
	cast = {
           "Jerry Seinfeld": "Jerry Seinfeld",
           "Julia Louis-Dreyfus": "Elaine Benes",
           "Jason Alexander": "George Costanza",
           "Michael Richards": "Cosmo Kramer"
       }
	When you iterate through a dictionary using a for loop, doing it the normal way (for n in some_dict) will only give you access to the keys in the dictionary - which is what you'd want in some situations. In other cases, you'd want to iterate through both the keys and values in the dictionary. 
	Iterating through it in the usual way with a for loop would give you just the keys, as shown below:
		for key in cast:
			print(key)
	If you wish to iterate through both keys and values, you can use the built-in method items like this:
		for key, value in cast.items():
			print("Actor: {}    Role: {}".format(key, value))		
